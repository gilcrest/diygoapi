# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

DIY Go API is a RESTful API template backed by PostgreSQL. It demonstrates a multi-tenant B2B SaaS data model with CRUD operations for movies as the demo domain. The project favors the Go standard library, using third-party packages only when necessary.

## Build & Run Commands

**Build tool**: [Mage](https://magefile.org/) (Go-based make alternative), defined in `magefiles/magefile.go`.

| Command | Description |
|---|---|
| `mage -v run local` | Run the server locally |
| `mage -v testall false local` | Run all tests (non-verbose) |
| `mage -v testall true local` | Run all tests (verbose) |
| `go test ./...` | Run tests directly (requires env vars set) |
| `go test -v -run TestFunctionName ./path/to/package` | Run a single test |
| `mage -v newkey` | Generate a new encryption key |
| `mage -v cueGenerateGenesisConfig` | Generate genesis config from CUE schemas |
| `task db-up` | Run database DDL migrations |
| `mage -v gcp staging` | Build Docker image and deploy to GCP Cloud Run |

The `env` parameter for mage commands (e.g., `local`, `staging`) determines which config profile to load. Config is loaded from `config_profiles.json` or environment variables.

## Architecture

### Layer Structure

```
HTTP Request → server (routes/middleware/handlers) → service (business logic) → sqldb/datastore (data access) → PostgreSQL
```

- **Root package (`diygoapi.go`)**: Domain types, interfaces (`Datastorer`, service interfaces like `MovieServicer`, `OrgServicer`, `AppServicer`), and request/response structs.
- **`server/`**: HTTP routing (`routes.go`), middleware chains (`middleware.go`), and handlers (`handlers.go`). Uses `justinas/alice` for composable middleware. Routes use Go 1.22+ method-pattern syntax (e.g., `"POST /api/v1/movies"`).
- **`service/`**: Business logic implementations. Services are structs with a `Datastorer` field and optional `EncryptionKey`. Transactions managed here.
- **`sqldb/datastore/`**: SQL queries generated by [sqlc](https://sqlc.dev/). Type-safe database access via `pgx/v5`.
- **`cmd/`**: CLI wiring — flag parsing via `peterbourgon/ff/v3` (supports flags, env vars, config files), server initialization, dependency injection.

### Middleware Chain

Every route uses a middleware chain built with `alice`. Typical chain:
```
loggerChain → addRequestHandlerPattern → enforceJSONContentType → appHandler → authHandler → authorizeUserHandler → jsonContentTypeResponse → handler
```

### Error Handling (errs package)

Based on the Upspin error pattern. Every function declares `const op errs.Op = "package/Function"` at the top and wraps errors with `errs.E(op, ...)`.

Key types: `Op` (operation trace), `Kind` (error classification: Validation, Unauthenticated, Unauthorized, etc.), `Code` (machine-readable), `Param` (related parameter), `Realm` (WWW-Authenticate).

Errors propagate up the call stack with op context. `errs.HTTPErrorResponse()` maps `Kind` to HTTP status codes. Internal/Database errors are not leaked to clients.

### Authentication & Authorization

- OAuth2 via Google (token validated against Google's OAuth2 v2 API)
- Bearer token required in `Authorization` header on all requests
- RBAC: Users have roles, roles have permissions, permissions map to resources
- Context carries `App`, `User`, and `AuthParams` through the request lifecycle

### Database

- PostgreSQL with `pgx/v5` connection pooling
- Migrations: SQL files in `scripts/db/migrations/up/` (numbered 000–014)
- Uses PostgreSQL schemas for tenant isolation (search_path)
- No ORM — raw SQL + sqlc code generation

### Configuration

Flags → environment variables → config file (precedence order). Key env vars:
`DB_HOST`, `DB_PORT`, `DB_NAME`, `DB_USER`, `DB_PASSWORD`, `DB_SEARCH_PATH`, `ENCRYPT_KEY`, `PORT`, `LOG_LEVEL`, `LOG_LEVEL_MIN`, `LOG_ERROR_STACK`

### Logging

Structured JSON logging via `rs/zerolog`. Logger passed through request context. GCP-compatible log hooks in `logger/` package.

## Key Conventions

- **Testing**: Uses `frankban/quicktest` (`c := qt.New(t)`), table-driven subtests
- **Error ops**: Always `const op errs.Op = "package/Function"` as first line, wrap with `errs.E(op, err)`
- **External IDs**: API responses use external IDs (UUIDs), never internal database IDs
- **Service constructors**: Services are struct literals with injected dependencies (no constructor functions)
- **Domain interfaces**: Defined in root package, implemented in `service/`
