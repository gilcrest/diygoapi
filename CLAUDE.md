# CLAUDE.md

This file provides guidance to [Claude Code](https://claude.ai/code) when working with code in this repository.

## Project Overview

DIY Go API is a RESTful API template (built with Go) backed by PostgreSQL. The goal of this project is to be an example of a relational database-backed REST HTTP Web Server that has characteristics needed to ensure success in a high volume environment. It co-opts the DIY ethos of the Go community and does its best to "use the standard library" whenever possible, bringing in third-party libraries when not doing so would be unduly burdensome (structured logging, OAuth2, etc.).

The "business" domain is a simple movie CRUD (**C**reate, **R**ead, **U**pdate, **D**elete) API, but the underlying data model is set up to enable a B2B multi-tenant SaaS, which is overkill for a simple CRUD app, however, it's the model I wanted to create and teach myself.

## Build & Run Commands

**Build tool**: [Taskfile.dev](https://taskfile.dev/) — tasks defined in `Taskfile.yml`.

| Command | Description |
|---|---|
| `task run` | Run the server |
| `task test` | Run all tests |
| `task test-verbose` | Run all tests (verbose) |
| `go test -v -run TestFunctionName ./path/to/package` | Run a single test |
| `task new-key` | Generate a new encryption key |
| `task db-create-user` | Create the `dga_local` database user via psql |
| `task db-up` | Run database DDL migrations |
| `task gen-config` | Generate config from CUE schemas |

Database tasks (`db-create-user`, `db-up`) read connection info from `./config/config.json` by default (using the `default_target` in the config). To override the target: `task db-up -- --target prod`.

--------

## Architecture

### Layer Structure

```
HTTP Request → server (routes/middleware/handlers) → service (business logic) → sqldb/datastore (data access) → PostgreSQL
```

- **Root package (`diygoapi.go`)**: Domain types, interfaces (`Datastorer`, service interfaces like `MovieServicer`, `OrgServicer`, `AppServicer`), and request/response structs. This is inspired by the [WTF Dial app repo](https://github.com/benbjohnson/wtf) and [accompanying blog](https://www.gobeyond.dev/) from [Ben Johnson](https://github.com/benbjohnson) — domain interfaces are defined here and implemented in `service/`.
- **`server/`**: HTTP routing (`routes.go`), middleware chains (`middleware.go`), and handlers (`handlers.go`). Uses [`justinas/alice`](https://github.com/justinas/alice) for composable middleware. Routes use Go 1.22+ method-pattern syntax (e.g., `"POST /api/v1/movies"`).
- **`service/`**: Business logic implementations. Services are structs with a `Datastorer` field and optional `EncryptionKey`. Transactions are managed here. Services are struct literals with injected dependencies (no constructor functions).
- **`sqldb/datastore/`**: SQL queries generated by [sqlc](https://sqlc.dev/). Type-safe database access via `pgx/v5`. No ORM — raw SQL + sqlc code generation.
- **`cmd/`**: CLI wiring — flag parsing via [`peterbourgon/ff/v3`](https://github.com/peterbourgon/ff) from [Peter Bourgon](https://peter.bourgon.org), server initialization, dependency injection.

### Middleware Chain

Every route uses a middleware chain built with `alice`. A typical chain looks like:
```
loggerChain → addRequestHandlerPattern → enforceJSONContentType → appHandler → authHandler → authorizeUserHandler → jsonContentTypeResponse → handler
```

### Error Handling (errs package)

Based on [Rob Pike's Upspin error pattern](https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html) (modified to meet my needs). The post is many years old now, but I find the lessons there still hold true.

By convention, every function declares `const op errs.Op = "package/Function"` as the first line and wraps errors with `errs.E(op, ...)`. The `errs.E` function is variadic and can take several different types to form the custom `errs.Error` struct.

Key types:
- `Op` — operation trace, builds the error stack as errors propagate up the call stack
- `Kind` — error classification (`Validation`, `Unauthenticated`, `Unauthorized`, `Internal`, `Database`, etc.)
- `Code` — machine-readable short code for client error handling
- `Param` — the parameter related to the error
- `Realm` — used in the `WWW-Authenticate` response header

`errs.HTTPErrorResponse()` maps `Kind` to HTTP status codes. Internal/Database errors are never leaked to clients — they return a generic "internal server error" message. `Unauthenticated` and `Unauthorized` errors return empty response bodies per the spec.

> Note: There are helpers like `errs.MissingField` (returns "field is required") and `errs.InputUnwanted` for common validation patterns.

### Authentication & Authorization

- OAuth2 via Google (token validated against Google's OAuth2 v2 API)
- Bearer token required in `Authorization` header on all requests
- App authentication via `X-APP-ID` and `X-API-KEY` headers (or falls back to provider Client ID lookup)
- RBAC: Users have roles, roles have permissions, permissions map to resources (endpoints)
- Context carries `App`, `User`, and `AuthParams` through the request lifecycle

### Database

- PostgreSQL with `pgx/v5` connection pooling
- Migrations: SQL files in `scripts/db/migrations/up/` (numbered 000–014)
- Uses PostgreSQL schemas for tenant isolation (`search_path`)

### Configuration

The [ff](https://github.com/peterbourgon/ff) library from [Peter Bourgon](https://peter.bourgon.org) is used to parse flags. Flags take precedence, so if a flag is passed, that will be used. If there is no flag set, then the program checks for a matching environment variable. If neither are found, the flag's default value will be used. The config file defaults to `./config/config.json`.

The CUE-based config setup uses a split layout:
- **`config/cue/schema.cue`** — the shared validation schema (checked into git)
- **`config/config.cue`** — local config values with credentials (gitignored)
- **`config/config.json`** — generated output from `task gen-config` (gitignored)

Key env vars: `DB_HOST`, `DB_PORT`, `DB_NAME`, `DB_USER`, `DB_PASSWORD`, `DB_SEARCH_PATH`, `ENCRYPT_KEY`, `PORT`, `LOG_LEVEL`, `LOG_LEVEL_MIN`, `LOG_ERROR_STACK`

### Logging

Structured JSON logging via [`rs/zerolog`](https://github.com/rs/zerolog) from [Olivier Poitrey](https://github.com/rs). The logger is initialized at startup and added to the request context through middleware, which pre-populates fields like request method, URL, status, duration, remote IP, user agent, and a unique `Request-Id`. The `Request-Id` is also sent back as a response header, allowing you to link request and error logs. GCP-compatible log hooks are in the `logger/` package.

--------

## Key Conventions

- **Testing**: Uses [`frankban/quicktest`](https://github.com/frankban/quicktest) (`c := qt.New(t)`), table-driven subtests
- **Error ops**: Always `const op errs.Op = "package/Function"` as first line, wrap with `errs.E(op, err)`
- **External IDs**: API responses use external IDs (UUIDs), never internal database IDs. I try to never expose primary keys.
- **Service constructors**: Services are struct literals with injected dependencies (no constructor functions)
- **Domain interfaces**: Defined in root package, implemented in `service/`

--------

## Key Terms

- **Person**: A being that has certain capacities or attributes such as reason, morality, consciousness or self-consciousness.
- **User**: Akin to a persona — a Person can have one or many Users (for instance, I can have a GitHub user and a Google user, but I am just one Person). Roles are assigned at the User level for fine-grained access control.
- **App**: An application that interacts with the system. An App always belongs to just one Org.
- **Org**: Represents an Organization (company, institution or any other organized body of people with a particular purpose). An Org can have multiple Persons/Users and Apps.
